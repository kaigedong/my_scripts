为什么epoll (select/poll的升级版) 那么快？
有两个原因：

1、创建共有内存空间来维护文件句柄列表

我们自己写程序的轮询是程序维护一个文件句柄列表，保存文件句柄，进行轮询，让操作系统去查询文件是不是准备好了。
自己的程序在用户态(用户的内存空间中)，操作系统在内核态(内核的内存空间)，比如有4G的内存，操作系统占高1G内存地址，用户占低3G内存地址。

用户程序维护的文件句柄，需要拷贝到内核态来查询，内核态查询完之后，拷贝回给文件，这样来回非常占用资源。

而epoll是创建了一个独立的内存空间，这个内存空间既不属于内核，也不属于用户程序，而是**两者共有的**，这样，用户程序在请求系统查询的时候就不需要拷贝文件句柄了。

这是第一个改进的地方，相对于用户自己写的轮询的异步程序。

2、报告机制：不采用轮询

举个例子，在select/poll 中，当检测到文件句柄有变化时(有写入啥的)，需要轮询来看哪个文件句柄满足了可操作的条件，这个轮询是花费时间的。

而epoll 不是通过轮询，而是文件句柄自己报告，满足了条件。

poll最多只能有1024个文件句柄，这是跟内核啥的有关，想要改变它就需要重新编译内核；而select能通过**修改配置文件**的方式，改变文件句柄的最大数量 (因为文件句柄最多有多少个保存在一个文件里)。

比如我们有上万个文件连接，如果每个都很快接收到内容，那么采用select与epoll 效率差不多；而有很多个连接，只有其中几个接收到了内容，那么epoll就会快很多，这就是因为epoll的消息报告。

epoll 有三个关键函数，第一个是创建一个**红黑二叉树**，这是平衡二叉树里性能最好的一个，传入需要维护多少个文件句柄的int参数，然后创建内核和用户程序公用的空间来维护它，

然后返回一个int值：注意！这个返回值是红黑二叉树的头结点。

第二个关键函数是对红黑树进行的操作：添加节点、删除节点、修改节点：添加节点来对这个文件句柄(如socket)进行监控，或移出树，不再对其监控等

第三个是等待，在给定的time时间内，如果监控的文件句柄有事件发生，就返回用户态的进程。


到目前，还是不明白这个报告是怎么报告的，大概是第三个函数没理解秦楚。

这个内容似乎不错：https://blog.csdn.net/lixungogogo/article/details/52226479 虎头看看
确实不错，如下：

## epoll
在Linux网络编程中，很长时间都是使用select来做事件触发。在Linux新的内核中，有了一种替换它的机制，就是epoll。

相比于select，epoll最大的好处在于他不会随着监听fd数目的增长而降低效率。因为在内核中select的实现中，它是**采用轮询来处理的**，轮询的fd数目越多，耗时越多。

相对于select和poll来说，epoll更加灵活，没有描述符数量限制。

epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个`事件表`中，这样在用户空间和内核空间的copy只需要一次。

## epoll 接口
epoll操作过程需要3个接口，分别如下：
```
# include <sys/epoll.h>

int epoll_create(int size);
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
```
首先要调用epoll_create建立一个epoll对象。参数size是内核保证能够正确处理的最大文件句柄数，多于这个最大数时内核可不保证效果。

epoll_ctl 可以操作上面建立的epoll，例如，将刚建立的socket加入epoll中让其监控，或者把epoll正在监控的某个socket句柄移出epoll，不再监控它等等。

epoll_wait 在调用时，




